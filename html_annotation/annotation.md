
## 目次

* アノテーションとは？
* 定義の仕方
* 標準アノテーション
* ライブラリのアノテーション

---

## アノテーションとは？

ソースコードにメタ情報を仕込むことで、開発者やコンパイラ、実行環境に対して、そのコードの意図を伝えるもの。


標準で組み込まれているもの

* JavaDoc
* Override
* SupppressWarnings
* Depricated

--

### 普通のコードとは違うの？

よりストレートに開発者の意図を伝えられる。

〜Java1.4では、命名パターンでチェックしたりしていた。（JUnit3.Xなど）

これでは正確じゃないし、間違ってるのかどうなのかわかりにくかった。

--

### 使うとどう便利になるの？

マーカーをつけておくことで、裏で対象のコードを見つけるのが容易になる。

例：[自作テストユニット](https://github.com/uryyyyyyy/JavaStudy/tree/master/src/study/annotation)

---

## 定義の仕方

```java
public @interface SampleAnnotation{
	//elements
}

```

要素がない場合はマーカアノテーションと呼ばれる。（コンパイラが読む用。）


---

## 標準アノテーション

---

## SuppressWarnings

警告を隠す

使うべきでないが、やむを得ない場合でも理由は明記するべき。


---

## メタアノテーション

普通は使わないので省略（フレームワーク系か、リフレクション呼びたいときなど）

* @Retention
* @Target
* @Inherited
* @Documented

---

## マーカの使いドコロとInterfaceとの比較

Interface
コンパイル時にチェックされる。
型安全が保証される
実装に依存する


アノテーション
実行時にチェックされる。
型安全でない。
実装に依存しないため、プラグインなどと分離しやすい。


* 構文補助
* 宣言的プログラミング（このコードは何の分類かを明記できる。）

---

## JavaDoc

* @author
* @version
* @deprecated
* @return
* @params
* 
* 
* 




http://www.docjar.com/html/api/java/lang/Override.java.html






---

### 35 命名パターンよりアノテーションをえらぶ。

#### 理由
命名パターンで、これはテストメソッドと定義したとしても、それはコンパイラにはわからなく、変な命名でも問題なく通るが、そのメソッドはテストされない。

アノテーションで明示するとコンパイラが、あぁコイツはコントローラか、とわかる。

#### コメント

スプリングでも多用される手法。
例えば、「このデータはここにDIしてね。」とか、
「このクラスはコントローラね」
とか。
特にメソッドに有効。クラスには後述するマーカインタフェースが有用。

---

### 36 常にOverrideアノテーションを使用する。

#### 理由

もしオーバーライドできてなかったときにエラーを吐いてくれる(引数が違うとか名前間違えたとか。)

#### koment

---

### 37 型を定義するためにマーカーインタフェースを使用する

#### 理由
実際に動かす際も規定できる,


#### コメント
先ほどのアノテーションと同様に、コンパイラにわからせるために使う。
