

## 目次

* 単語の意味の確認
* なぜ関数型か？
* よくありそうな問題と解決法
* 結論
* 実践編


---

## 断り書き

オブジェクト指向を否定するものでも、関数型バンザイでもありません。
そもそも対立する概念ではないので、適材適所で使いましょうという話です。

各種資料を参考にしているものの、理解度の確認のために自分の言葉で書いています。

ツッコミどころが多いかと思うので、ぜひご指摘ください。

---

### 単語の意味（曖昧）

単語の定義はややこしいので簡略化してます。


* オブジェクト指向プログラミング
	- とりあえずオブジェクト同士が連携して処理を投げ合うモデルの総称。

* オブジェクト
	- 上記のオブジェクト指向においての処理の基本単位。

* 関数型プログラミング
	- 不変オブジェクト・参照透過性を徹底した記述方式。
	- 関数をファーストクラスとして扱う言語を関数型言語という。

--

### 単語の意味（曖昧）

* 関数
	- 副作用を持たず、参照透過性を確保した処理の基本単位。

* 副作用
	- 一般に、「IOを扱う」「変数の値を変える」こと。
	- 例：setter・ファイル出力

* 参照透過性
	- 同じ入力なら常に同じ出力になる性質。

---

## そもそも、なぜ関数型か？

--

### テクノロジーが進歩した。

* 一台のマシンより複数台で協調
	- 並列性・非同期
* コンパイラ・処理系が賢くなった。
	- 型推論・より高次の記述が出来る
* マシンパワーの向上
	- 人より自動テストのが速くて正確。

　

→手続き的でない、より抽象度の高い記述の必要性。

--

### オブジェクト指向が難しかった。

* メッセージパッシング？
* 継承・抽象クラス？
* カプセル化？
* 「そもそもオブジェクトって何だよ！」

専門家でも意見が割れている。「○○の言うオブジェクト指向」

　

→別のパラダイムが必要なのでは。

---

## そもそもプログラムとは

`入力→処理→出力`


* オブジェクト指向プログラミング
	- オブジェクトに入力して結果を返す。
* 関数型プログラミング
	- 関数に入力して結果を返す。

　

→やってることは同じ。

--

## じゃぁ何が違う？

* オブジェクト指向
	- 内部に状態を持っている。
	- 事前のパラメータ・タイミングによって結果が変わることがある。
	- （フィールド変数を持たないオブジェクトはもはや関数と同じでしょ？）

* 関数
	- そもそも状態を持たない。
	- 入力値が同じなら常に同じ結果が帰ってくる

--

## 個人的に思う良いプログラム

プログラマが考えることが少なくて済むもの、怠けられるもの。

![alt](./img/namaketai.jpg)

[せのちょや -Se-C-](http://blog.livedoor.jp/k_azk216/archives/1120211.html)

--

具体的には、

* 「こういうことがしたい」だけ書いて、実際のアルゴリズムや処理は任せる。
	- 手続き的より宣言的
* プログラムを読むときに覚えておくこと（脳内スタック）を減らす。
	- 状態を追う必要がない方が楽

　

→**関数型プログラミングはすごくそれに近い**


---

### よくありそうな問題

「ちょっと便利なライブラリを作ってみたから共有するよ。」

「はじめにここにこの値を入れて、次にこうするとココに結果が〜〜」

→順番通りにやらない人が出てきてバグる。

→「え、そういう使われ方するなんて想定してないよ。この順番通りやってくれないと困るよ。。。」

--

### よくありそうな問題

「前の人の書いたコード、こんなとこにいい感じのメソッドがおいてある。これ使えそうだな。」

→そのメソッドの中で、予想してない副作用があってバグる。

→「え、まさかこのメソッドがそこに影響を与えてるとは思わなかった。。。」


--

### これらの問題の原因

そのオブジェクトの振る舞いの認識が開発者同士で異なっていた。

* 開発者同士で、そのオブジェクトの振る舞いをちゃんとすり合わせる必要がある。

--

### 本質的な原因

オブジェクトの振る舞いの認識が人によって異なる可能性がある。

* オブジェクトの定義が明確でない or 変化すること

--

### 改善策

* １. そのオブジェクトの振る舞いをきちんとJavaDocなどに残しておく。ミーティングなどで共有する。

* ２. そもそも誰でも誤解なく使えるようにする。

　

→１は覚えることが増えるから嫌だ。怠けるためには２にしたい。

---

### 誰でも誤解なく使えるように

誰でも使えるようにするためには、

* 入力値さえ同じならいつ実行しても同じ結果になる。
* 入力値が正しいかどうかは型で判断する。
* 副作用は想定しにくい＆確認するのが難しいため避ける。

　

→これらを踏まえるとだいたい関数型プログラミング。

（個人的には、関数型プログラミングは以下の認識です。）

* 『イミュータブルオブジェクト指向』
* 『well‐definedオブジェクト指向』


--

### 関数型の副次的効果

* 読みやすい
	- 手続き的でないため、記述が抽象的なレベルで済む。
	- 結果が推測できる。余計な変数の使い回しなどが少ない。
	- **誰が見ても誤解がないためにはこれも重要。**

* 並列処理・遅延評価しやすい。
	- 入力値さえ与えられれば、いつどこで処理をしても同じ結果になる。

* テストしやすい。
	- 入出力だけチェックすれば良いので楽。

--

### 関数型のデメリット

* 副作用なしは現実にはありえない
	- クライアント・DB・ファイルとのデータのやりとりは必須。

* イミュータブルは処理効率が悪いケースもある。
	- 一部だけ書き換えれば済むのに全て直す場合
	- JavaでStringBuilderとか使うケース。

--

### その対応策

* 副作用について。
	- 影響を局所化してしまう。純粋な関数と副作用系（主にIO）を分ける

* 処理効率について
	- 最適化はあとで考えればよい
	- [Rob Pike のプログラミングに関する5つの掟](http://mattn.kaoriya.net/software/rob-pike-s-5-rules-of-programming.htm)
	- どうしてもの場合は影響を局所化

---

## まとめ

とにかく開発者が覚えなきゃいけないことを減らす。

そのためには、

* 役割を明確にし、曖昧な箇所を減らす
* 機械にできることは機械にやらせる

　

→関数型言語はこれらを言語レベルでサポートしてくれる。

--

### 役割を明確にし、曖昧な箇所を減らす

![alt](./img/object.png)


から、

![alt](./img/functional_object.png)

に適切に分離すること。

これによって、純粋な関数においては考えることが著しく減る。


--

### 機械にできることは機械にやらせる

* 実行時デバッグより自動テスト。
* メソッドの中まで確認するより、イミュータブルと明示。
* ドキュメントで共有するより、型チェック。
* 「どう実行するか」より、「何をしたいのか」だけ記述する。
	- （関数型言語の）コンパイラ・ライブラリによっては、内部で最適なアルゴリズムになるように書き換えてくれたりする。

--

### オブジェクト指向との関係

オブジェクト指向、というだけでは意味がわからないから、
役割毎に明確に責務を分けましょうというのが関数型。

* まとまりの概念がないと、無数の関数がバラバラと存在して収集がつかなくなる。
* データ構造も、一定の組み合わせでまとまっているから意味がある。
* 役割毎に分類することが必要で、その入れ物がオブジェクト。

--

### Javaでもできる

関数型プログラミングは関数型言語を使わないと出来ないわけではありません。

特にJava８ではラムダなどが導入されて書きやすくなっています。

もちろん純粋関数型言語ほどとはいきませんが、思想を取り入れることできれいなコードが書けるようになるのでは。

　

次ページから、比較してみます。


---


### 実践編

どうやって、

* 副作用と関数を切り離すか
* イミュータブルで処理を書くか
* 状態をなくせるか
* 直感的に書けるか


を、ScalaとJavaの比較から学びます。


--

### 但し書き

関数型っぽい記述は、Javaでも書こうと思えば書けます。

ただ、言語レベルでサポートがないため信頼性に乏しかったり、よりわかりやすく書けるAPIが用意されている程度です。


---

### オブジェクトを意味で分ける。

* データ構造
	- データの入れ物。
	- 一般にDTOやVOなどと呼ばれるオブジェクトの総称。

* 関数
	- あるデータを入れると処理して返すオブジェクト。

* 副作用のあるメソッド
	- 副作用を含む処理をするオブジェクト。
	- 一般に外部と連携するIO系の処理を担う。

---

## データ構造

〜いつからだろう。「＝」を等号でなく代入だと思うようになったのは〜

--

### データ構造とは

データの入れ物。Javaで言うVOやDTOなどに相当する。

このあたりの定義はプロジェクトによって異なることがある。

　

[BeanとDTOとEntityとVOとFormの違いって何？](http://yyyank.blogspot.jp/2013/07/javabeansbeandtoentityvoformwhat-is.html)



--

### 何が嬉しいのか？

* 状態を持つオブジェクトがこれだけになる。
* 状態が不変なので理解しやすい。
* （関数型言語では）代数的データ型としてパターンマッチが使える。


--

### Scalaでの書き方

```
case class Human( name:String , age:Int )

```

これだけで、データ構造として持ってて欲しい各種メソッドを用意してくれる。

[参考](http://d.hatena.ne.jp/xuwei/20101005/1286303814)

--

### Scalaでの書き方２

```
# in REPL
scala>val numbers = Set(1, 2, 3)
numbers: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
```

デフォルトでimmutable（不変）Setになっている。

mutable（JavaのSetと同じ）にしたければ明示的にimportしてあげる必要がある。

--

### Scalaでの書き方

さらにパターンマッチを使うと、if文より遥かに簡単に色々な条件分岐ができる。
（代数的データ型として扱えるらしい。）

今回は省略する。[参考](http://qiita.com/f81@github/items/aa46c248a38a171ed955)


--

### Javaで真似をするには

* [lombok](http://projectlombok.org/features/Data.html)を使う。
* IDEに生成してもらう。
* 全ての変数にfinalを付ける。（もちろんSetterは不要）


---

## 関数

![alt](./img/miku_function.jpg)

[ねとらぼ](http://nlab.itmedia.co.jp/nl/articles/1305/02/news063.html)

--

### 関数とは何か？

* 数学における関数の概念と同じ。
	- ある入力値を与えると結果を返すもの。

* 参照透過性を持つ。

* 関数型プログラミングでは、関数は値として存在する。
	- 組み合わせやすい。


--

### 何が嬉しいのか？（再掲）

* 状態を考慮せずとも挙動がわかる。
* 細かい粒度で作っていくことで、どんどん処理を抽象化できる。
* テストしやすい。（Mockとかいらなくなる）
* 並列処理させやすい。
* （関数型言語では）常に同じ結果になるのでキャッシュが効く。
* （参照透過なら全てpublicでもいいよね。）


--

### Scalaでの書き方

純粋な関数であることを言語レベルで保証しているわけではないので、Javaとあまり変わらない。

ただ、関数を引数に取るAPIが用意されていたり、
部分適用などができて、より簡単に関数を扱える。

（関数を引数に取るAPIはJava8のStreamのイメージ）

* [Scalaでカリー化と部分適用](http://qiita.com/f81@github/items/e8bfab96b4be9e404840)
* [Scalaの機能 カリー化 部分適用](http://divide-et-impera.org/archives/835)

--

### Scalaでの書き方

手続き的なループではなく、再帰を使うのが関数型流。

再帰の欠点であるスタックオーバーフローもscalaだと（少し）サポートしている。

（ただ、別にどっちでもいいじゃんと思う。）

* [マンガで分かる Java入門講座](http://manga.crocro.com/?cat=java&pg=recursive_method)
* [Scalaで再帰プログラミング](http://bach.istc.kobe-u.ac.jp/lect/ProLang/org/scala-recursive.html#sec-4)

--

### Javaで真似をするには

* Java8のラムダ・@Functionalを使う。
* 状態を持たないオブジェクトにメソッドを記述する。
* 副作用のあるもの（Dao・File操作・Servlet etc...）を外へ追い出す。
* （Loggerは特別扱いでいいかも。）

---


### 副作用のある処理

![alt](./img/fukusayou.gif)

[水戸クリニック](http://www.tenkan.jp/fukusayou.htm)

--

#### 副作用のある処理とは何か？

一般に、「IOを扱う処理」「変数の値を変える処理」を副作用のある処理。

純粋関数型言語では副作用のある処理は隔離するように強制されますが、JavaやScalaはそこまで徹底してくれません。

が、開発者同士で徹底することで分離させることは可能です。

（うっかりバグが入り込む可能性は否定できませんが。）


--

### Scalaでの書き方


純粋関数型言語でないので分割は保証されない。（Javaと同じレベル）

ただ、例外は基本的に非チェック例外で、
外に漏れ出さないようになっている。


--

### Javaで真似をするには

* 役割毎にオブジェクトを分ける。
* Dao・Fileアクセス・日付取得・などの処理は局所化する。
* 例外を引きずらない（純粋な関数じゃなくなってしまう）


---

### Q

* 副作用のあるメソッドを含む処理のテストはどうすれば？

例えばこんな感じ（例なのでJava）

```
public ReturnObj myFunction(Object1 obj1) {
	Object2 obj2 = pureFunction(obj1); //純粋な関数
	Object3 obj3 = sideEffectMethod(obj2); //副作用のある処理
	return heavyFunction(obj3); // 純粋な関数だけどテストするには時間かかる。
}
```

ｍｙFunctionをテストしたい場合に、JavaでいうDIのような仕組みはあるのか？

--

### Q

* 実行時デバッグはしない前提なのか？

自分の書いたプログラムが合っているのかどうかは自動テストで確認することになるのか。

--

### Q

* モナドの理解は必須なの？どう学んだらいいの？

僕はHaskel書けないのでよくわかりません。

---

### Any Questions？

![alt](./img/aiaru_batou.jpg)

[愛ある罵倒](http://www.fwinc.co.jp/batou/batou.php)

---


### Reference

* [f81@github](http://qiita.com/f81@github)

* [オブジェクト指向プログラマが次に読む本](http://www.amazon.co.jp/dp/4774144363)

* [関数型言語が普及しない理由](http://pg-kura.hatenablog.com/entry/20111114/1321236695)

* [ゆるよろ日記](http://yuroyoro.hatenablog.com/)
