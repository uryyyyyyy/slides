

## 目次

* 前提
* そもそも、なぜ関数型か？
* よくありそうな開発現場の問題
* 誰でも誤解なく使えるように
* 結論


---

## 断り書き

オブジェクト指向を否定するものでも、関数型バンザイでもありません。
そもそも対立する概念ではないので、適材適所で使いましょうという話です。

各種資料を参考にしているものの、理解度の確認のために自分の言葉で書いています。
ツッコミどころが多いかと思うので、ぜひご指摘ください。

---

### 前提

単語の定義はややこしいので簡略化してます。


* オブジェクト指向プログラミング
	- とりあえずオブジェクト同士が連携して処理を投げ合うモデルの総称。

* オブジェクト
	- 上記のオブジェクト指向においての処理の基本単位。

* 関数型プログラミング
	- 不変オブジェクト・参照透過性を徹底した記述方式。

* 関数
	- 副作用を持たず、参照透過性を確保した処理の基本単位。

* 副作用
	- 一般に、「IOを扱う」「変数の値を変える」こと。（例：setter・ファイル出力）

---

## そもそも、なぜ関数型か？

--

### テクノロジーが進歩した。

* 一台のマシンより複数台で協調
	- 並列性・非同期
* コンパイラ・処理系が賢くなった。
	- 型推論・より高次の記述が出来る
* マシンパワーの向上
	- 人より自動テストのが速くて正確。

　

→手続き的でない、より抽象度の高い記述の必要性。

--

### オブジェクト指向が実際にやってみるとややこしいため。

* メッセージパッシング？
* 継承・抽象クラス？
* カプセル化？
* 「そもそもオブジェクトって何だよ！」

専門家でも意見が割れている。
プロジェクト内で意見の統一はとれているのか？

　

→別のパラダイムが必要なのでは。

---

## そもそもプログラムとは

`入力→処理→出力`


* オブジェクト指向プログラミング
	- オブジェクトに入力して結果を返す。
* 関数型プログラミング
	- 関数に入力して結果を返す。

やってることは同じ。

--

## じゃぁ何が違う？

* オブジェクト指向
	- 内部に状態を持っている。
	- 事前のパラメータ・タイミングによって結果が変わることがある。
	- （フィールド変数を持たないオブジェクトは、もはや関数と同じでしょ？）

* 関数
	- そもそも状態を持たない。
	- 入力値が同じなら常に同じ結果が帰ってくる（副作用も同じ）

--

## 個人的に思う良いプログラム

プログラマが考えることが少なくて済む、怠けられるもの。

![alt](./img/namaketai.jpg)

--

具体的には、

* 「こういうことがしたい」だけ書いて、実際のアルゴリズムや処理は任せる。
* プログラムを読むときに覚えておくこと（脳内スタック）を減らす。

　

→**関数型プログラミングはすごくそれに近い**

決して関数型言語・関数型プログラミングが優れているというわけではない。
覚えることが少ない記述になりやすい、というだけ。

---

## よくありそうな開発現場の問題

> 「ちょっと便利なライブラリを作ってみたから共有するよ。」

> 「はじめにここにこの値を入れて、次にこうするとココに結果が〜〜」

> →順番通りにやらない人が出てきてバグる。

> →「え、そういう使われ方するなんて想定してないよ。この順番通りやってくれないと困るよ。。。」

--

> 「前の人の書いたコード、こんなとこにいい感じのメソッドがおいてある。これ使えそうだな。」

> →そのメソッドの中で、予想してない副作用があってバグる。

> →「え、まさかこのメソッドがそこに影響を与えてるとは思わなかった。。。」


--

### これらの問題の原因

そのオブジェクトの振る舞いの認識が開発者同士で異なっていた。

* つまり、開発者同士で、そのオブジェクトの振る舞いをちゃんと摺り合わせて記憶する必要がある。

--

### 本質的な原因

オブジェクトの振る舞いの認識が人によって異なる可能性がある。

* オブジェクトの定義が明確でない or 変化することが問題。

--

### 改善策

* １ そのオブジェクトの振る舞いをきちんとJavaDocなどに残しておく。ミーティングなどで共有する。

* ２ そもそも誰でも誤解なく使えるようにする。

→１は覚えることが増えるから嫌だ。怠けるためには２にしたい。

---

### 誰でも誤解なく使えるように

誰でも使えるようにするためには、

* 入力値さえ同じならいつ実行しても同じ結果になる。
* 入力値が正しいかどうかは型で判断する。
* 副作用は、普通想定できない＆確認するのが難しいため避ける。

　

→これらを踏まえるとだいたい関数型プログラミング。

（個人的には、関数型言語は『イミュータブルオブジェクト指向』『well‐definedオブジェクト指向』なのではと思っています。）

--

### 関数型の副次的効果

* 並列処理・遅延評価しやすい。
	- 入力値さえ与えられれば、いつどこで処理をしても同じ結果になる。

* 読みやすい
	- 結果が推測できる。手続き型にありがちな変数の使い回しなどが少ない。

* テストしやすい。
	- 入出力だけチェックすれば良いので楽。

--

### 関数型のデメリット

* 副作用なしは現実にはありえない
	- クライアント・DB・ファイルとのデータのやりとりは必須。

* イミュータブルは処理効率が悪いケースもある。
	- 一部だけ書き換えれば済むのに全て直すから。
	- JavaでもStringBuilderとか使うよね。

--

### その対応策

* 副作用について。
	- 影響を局所化してしまう。純粋な関数と副作用系（主にIO）を分ける

* 処理効率について
	- きちんとプロファイルとってボトルネックを突き止めてから改善すれば十分。その際も局所的に。

---

## 結論

とにかく開発者が覚えなきゃいけないことを減らす。

そのためには、

* 役割を明確にし、曖昧な箇所を減らす
* 機械にできることは機械にやらせる

--

### 役割を明確にし、曖昧な箇所を減らす

オブジェクト指向でよくある構成

IO 10%
状態持ったり副作用あるかも。あ、例外も出るかもしれない、という何か 90%

から、

IO 10%
副作用・例外が起きうる箇所 30%
純粋な関数 60%

に適切に分離すること。

これによって、純粋な関数においては考えることが著しく減る。

--

### 機械にできることは機械にやらせる

* 実行時デバッグより自動テスト。
* メソッドの中まで確認するより、イミュータブルと明示。
* ドキュメントで共有するより、型チェック。

--

### とはいえ。

オブジェクト指向のパラダイムも必要。

→オブジェクトというまとまりの概念がないと、無数の関数がバラバラと存在して収集がつかなくなる。
データ構造も、一定の組み合わせでまとまっているから意味がある。

役割毎に分類することが必要で、その入れ物がオブジェクト。

--

### 活用するためには

いきなり移せるものではない。

Javaは、言語としてnullが入りうるし、関数の扱いも少しやりづらい。
（ただ、Java８のラムダやOptionalでかなり改善されている。）

他の人が作ったプログラムにnullが入ってたり、finalと書かれていてもその内部のオブジェクトは変更される可能性があります。

ただ、それらの対処さえしておけば、保守しやすく、怠けやすいプログラムに近づけると思います。


---




### 実践編

どうやって、

副作用と関数を切り離すか
イミュータブルで処理を書くか
状態をなくせるか

を、関数型モデルのやり方から学びます。


--

### 但し書き

関数型っぽい記述は、Javaでも書こうと思えば書けます。

ただ、言語レベルでサポートがないため信頼性に乏しかったり、よりわかりやすく書けるAPIが用意されている程度です。


---

### オブジェクトを意味で分ける。

データ構造：データの入れ物。一般にDTOやVOなどと呼ばれるオブジェクトの総称。

関数：あるデータを入れると処理されて返してくれるだけのオブジェクト。

その他メソッド：副作用を含む処理をするオブジェクト。一般に外部と連携するIO系の処理を担う。

---

## データ構造

〜いつからだろう。「＝」を等号でなく代入だと思うようになったのは〜

--

### データ構造とは

関数型言語はデフォルトでイミュータブルをサポートしていますが、Javaでも簡単。finalを指定するだけ。

データの入れ物。Javaで言うVOやDTOなどに相当する。

おまけ：[BeanとDTOとEntityとVOとFormの違いって何？](http://yyyank.blogspot.jp/2013/07/javabeansbeandtoentityvoformwhat-is.html)

このあたりの定義はプロダクトによって異なることがある。

--

### 何が嬉しいのか？（再掲）

* 状態を持つオブジェクトがこれだけになる。
* 状態が不変なので理解しやすい。
* （関数型言語では）代数的データ型としてパターンマッチが使える。


--

### Scalaでの書き方

```
case class Human( name:String , age:Int )

```

これだけで、データ構造として持ってて欲しい各種メソッドを用意してくれる。→[参考](http://d.hatena.ne.jp/xuwei/20101005/1286303814)

--

### Scalaでの書き方

さらにパターンマッチを使うと、if文より遥かに簡単に色々な条件分岐ができる。

[参考](http://qiita.com/f81@github/items/aa46c248a38a171ed955)


--

### Javaで真似をするには

* lombokを使う。→[リンク](http://projectlombok.org/features/Data.html)
* IDEの力を借りて書く。

* 全ての変数にfinalを付ける。（もちろんSetterは不要）


---

### 関数

〜いつからだろう。数式を信用できなくなったのは〜

--

#### 関数とは何か？

数学における関数の概念と同じ。ある入力値を与えると結果を返すもの。

結果は引数の値のみに依存し、同じ入力なら常に同じ結果。（参照透過性と呼ばれる。）

関数型プログラミングでは、関数は値として存在する。→組み合わせやすい。


--

### 何が嬉しいのか？（再掲）

* 状態を考慮せずとも挙動がわかる。
* 細かい粒度で作っていくことで、どんどん処理を抽象化できる。
* テストしやすい。（Mockとかいらなくなる）
* 並列処理させやすい。
* （関数型言語では）常に同じ結果になるのでキャッシュが効く。


--

### Scalaでの書き方

（Javaも同じことは基本的にはできるよ。）

#### 高階関数・クロージャ・カリー化・部分適用

高階関数→関数を受け取り、関数を返す関数

クロージャ→引数以外に、内部で使用する変数を外部から取り込んでいる関数

カリー化→複数の引数を取る関数を、1つの引数を取る関数のチェーンに変換すること。（部分適用とは似て非なるもの。値の適用は範囲外）

部分適用→複数の引数を取る関数の一部の引数に値を適用した関数を返すこと。

※このあたり、一義に定まってないっぽいので合ってるか不安。。。


//TODO： サンプルコード

カリー化はちょっと便利な気もするけど、全体的にあんまり目新しさを感じないです。。。

オブジェクト指向でいう、オブジェクト内のローカル変数がfinal指定されてるものと思えばいいのでは。

（ところで、シンタックスシュガーって初心者向けっぽい響きだけど違うよね。玄人向けだからシンタックスビターじゃないかと思ったり。）


同時に、状態を持たないならオブジェクトとしてカプセル化しておく意味もない。全て公開してても問題ない。誰にいじられようが不変だから。


--

### Javaで真似をするには

* Java8のラムダ・@Functionalを使う。
* 状態を持たないオブジェクトにメソッドを書く。
* 副作用のあるもの（Dao・File操作・Servlet etc...）を外へまとめる。
* （Loggerは例外でいいかも。）

---


### 副作用のある処理

--

#### 副作用のある処理とは何か？

一般に、「IOを扱う処理」「変数の値を変える処理」を副作用のある処理といいます。
変数の値を変える処理はfinal指定していれば起きないので、IOを伴う処理全般とほぼ同義でしょう。

純粋関数型言語では副作用のある処理は隔離するように矯正されますが、JavaやScalaはそこまで厳密ではありません。

よって、言語レベルで副作用のないことを担保することはできませんが、開発者同士で徹底することで分離させることは可能です。
（ただ、うっかりバグが入り込む可能性は否定できませんが。）


--

### Scalaでの書き方

どうやって分けているか。

純粋関数型言語でないのでちゃんとやってない。


--

### Javaで真似をするには

役割毎にオブジェクトを分ける。

---



---

### メモ

オブジェクトにdefで定義された処理はメソッドと呼ばれる。これはオブジェクトに属しているため、関数オブジェクト単体として扱うためには複製してやる必要がある。

「_」を入れることで、引数に何も入れていない関数として取り出せるのでそれを使うのが一般的。


かりーかと部分適用

デフォルト引数って必要かな？

名前渡しパラメータ
関数の適用を遅らせるためか。
遅れて嬉しいのは副作用のある場合か。


## コレクション

Listに対してmapとかfilterとかforEachとか。

Java８もほぼ同等の機能を備えているので省略。

```

public List<Integer> toEvenList(List<Integer> list) {
	List<Integer> evenList = new ArrayList<Integer>;
	for(int value : list){
		if(value % 2 == 0){
			evenList.add(value);
		}
	}
	return evenList;
}

```


```
public List<Integer> toEvenList(List<Integer> list) {
	return list.stream().filter(value -> value % 2 == 0).collect(Collectors.toList)
}

```

### メモ

Tupleって、わざわざ新しいデータ構造を定義するまでもない場合に使うものだと思うけど、そんな場面あまり無くような。。。

## 再帰

関数型界隈では、ループより良いとされる

理由は、
命令的な余計なものがなくなり直感的になる。
ミューダブルな変数がなくなる。
から。

### デメリット
デバッグしにくくなる。


実行時デバッグより自動テストをする。
そのためにはテスタブルであること。

### 末尾再帰

一般に再帰はスタックが積まれていく。１０万とかの要素に対して再帰処理を行うとoverflowをおこしてしまう。

Scalaでは末尾再帰を用いることでstackの階層を下げることが出来る。
アキュミュレータを使うというパターンがある。


## 型

静的型付け言語の特徴は実行前にコンパイラがチェックしてくれること。
これを利用しない手はありません。

型を自在に扱ってこそJavaやScalaを使う意味があるというものです。

### 継承・抽象クラス

省略。Scalaは基本mixinを使う。

### 型クラス

パラメータ化された型・型コンストラクタともいう。



### 共変・非変・反変

なぜJavaのリストとかには共変はないのか？

JavaはImmutableListを強制できない。
つまりListに別の要素が追加されるおそれがある。

もし
List<E> eList = List<Esub> eSubList

ができてしまうとすると、

eList.add(newE)

ができてしまう。

するとeSubListにEのインスタンスが入り込んでしまい不整合になる。

これがimmutableであれば、別の型を持ったインスタンスが生成されるのでおｋ


## 並列

婚カレント パラレル

なぜするか
空き時間の活用。
応答性能の向上

プロセスよりスレッド。
プロセス感通信はオーバーヘッドが大きい。


##モニタ セマフォ

共有オブジェクトの状態を監視するもの。
同時アクセスの上限を規定するもの。

future

未来の値の格納スペース

spawn
別スレッドに処理させる定型文


### Reference


http://blog.livedoor.jp/k_azk216/archives/cat_22519.html

http://qiita.com/f81@github/items/e8bfab96b4be9e404840

http://www.amazon.co.jp/dp/4774144363

http://blog.livedoor.jp/k_azk216/archives/cat_22519.html
