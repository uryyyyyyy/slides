
## 最近のWebシステムの要件

- RDBじゃ遅い、もっと速く値を返して欲しい。
- DBは常に利用できるようにしてほしい。
- 超大量のデータを扱いたい。

→RDBの苦手な部分（高速・スケール）を補填するDBの必要性。

---

## 疑問

なんでこんなにたくさんの実装（NoSQLデータベース）があるのか？

→全ての要求を完璧に満たす分散DBが存在しないから（CAP定理・データモデル・永続化）


---

### CAP定理

![Link](./img/cap.png)

---

### CAP定理

- 分散システムに置いて、
- どのノードもいつでもアクセスできて、
- 常に一貫したデータを取得すること

は不可能。

**※ACIDのCとCAPのCは別モノなので注意。**

（※ ネットワーク障害を考慮しない単一DB系の場合はACになる。）

https://ja.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86

---

### CAP定理


イメージ

物理的に遠い二台のDBサーバーの通信には遅延が発生する。（[東京とサンフランシスコだと光速で数十ms](http://www.slideshare.net/hinakano/composer-phpstudy?ref=http://tech.mercari.com/entry/2016/02/01/164829#21)）

この時、ネットワーク障害があると２つの選択が必要になる。

- どちらのノードも処理を継続する。ただしデータの一貫性が損なわれる（AP）
- 一貫性を維持するために、どちらかor両方のノードが処理を一時的に止める（CP）

　

このバランスをどう調節するかがDB選定の肝になる。

---

## マスタ・スレーブ型

あるノードが特定の役割を持っているパターン。

一般的には、処理するマシンが決まっているのでデータの一貫性を維持しやすい・処理が速いなどの利点があるが、
役割の変更が起きている間に一部処理ができなくなる。

---

## Dynamo型

全てのノードがフラットに並べられているパターン

一般的には、常にデータの読み書きができて可用性に優れているが、
リクエストを受けるノードとデータを持つノードが別なので、速度が遅かったり、値の一貫性が壊れる場合がある。

Quorumの仕組みにより、一貫性とパフォーマンスの調整が可能。

(たぶん読み書きのスループットはマスタスレーブと同じ形でスケールする。)

---

### Quorum

読み書きの対象ノード数を調整することで、一貫性とレイテンシを調整する。

`読み込みｍ、書き込みｎ、全ノードN、レプリカl、m+n > l、m,n < l の場合`

一般的（Cassandra, Riak）には、どのノードへレプリカを作るかのアルゴリズムを共通して持っていて、それに該当するl個のノードに読み書きを行う。

- 書き込み時に、lのうちn個のノードにも同期を行い完了したらレスポンスを返す。
- 読み込み時に、lのうちm個のノードに問い合わせて正しい値を返す（最新のTimestampだったり、VectorClockだったりする。）

[参考](http://stackoverflow.com/questions/31651487/how-does-cassandra-scale-horizontally)

---

## データモデル

NoSQLデータベースには、

- ドキュメント指向
- KVS
- 列指向
- グラフ指向などがある。

それぞれのデータモデルによって得意とする処理が異なり、
もし不得意な領域を選んでしまうと要件を満たせなかったり、パフォーマンスが劇的に劣化したりする。

---

## KVS

Javaで言うHashMapのように、Keyを渡すとValueを返してくれるような単純なデータ構造。
単純な分処理が速いが、複雑なことをする場合にはクライアント側での対応が必要。

---

## ドキュメント指向

あるデータに任意のデータを関連させることができ、その関連データに応じて複雑なクエリを投げることができる。
NoSQLにおいてはスキーマレスなことが多く、柔軟なデータ構造を扱える。

---

## 列指向

大量のレコードに対しての集計系のクエリに特化した構造。
内部的には、データを持っている各ノードでMapReduce的なことをしていることが多い。

---

## グラフ指向

詳しくない。

---

## 永続化

データのロストを防ぐには色々な段階がある。

---

## インメモリ/HDD(SSD)

インメモリだと、速いがプロセスが落ちるとデータが失われる。
HDDで永続化するのが安全だが、処理が遅くなる。

![](./img/hdd_memory.gif)

---

## 同期/非同期レプリケーション

データの更新のリクエストがあった際に、その内容を別ノードでも保存することで障害時のデータロストを防ぐ。

- 同期の場合は、別ノードへの複製が済んでからリクエスト完了とするので、安全だが遅い。
- 非同期の場合は、別ノードへの複製が終わる前にリクエスト完了とするので、速いが安全でない。

---

## インデックス

（KVSの文脈ではあまり出てこないので省略。。。）

---

## その他要素技術

---

## Gossip Protocol

クラスタ構成時に、各ノード全てとやりとりするとN * N-1個のコネクションが必要になり非効率なので、
隣同士の相談で合意形成する仕組み。（その代わり時間がかかる）

[参考](http://www.slideshare.net/akuwano/cassandra-4098052#21)

---

## Paxos

クラスタ内のノード間での合意形成アルゴリズム。
分散システムでの一貫性の確保に利用されているらしい。（Zookeeperとか）
詳しくは知らない。

[参考](http://www.slideshare.net/pfi/paxos-13615514)

---

## 今回のターゲット

- Redis
- Memcached
- Cassandra
- Riak
- CouchBase
- Aerospike
- KyotoTyrant
- Zookeeper

---

仕組みと特徴で分類しているが、
仕組みはおそらく不変な抽象的なもの、
特徴は仕組みに応じた現段階での定量的な指標。

速度を書いていますが、だいたいの目安で。

（参考値：ローカルのメモリで0.05msくらい）

---

## Redis

- [リンク](http://redis.shibu.jp/admin/cluster/)
- [リンク](http://toufuegg.hatenablog.com/entry/2015/04/04/170309)
- [リンク](http://redis.io/topics/cluster-tutorial#creating-and-using-a-redis-cluster)
- [リンク](http://mocobeta-backup.tumblr.com/post/36435137765/kvs-memcached-couchbase-mongodb-redis)

---

### 一言で

高速かつ一貫性のある万能KVS。

---

### 仕組み

![](./img/hash_slots2.png)

- マスタ・スレーブ構成
- あるデータ（slot）に対するマスタは常に一つ。
- インメモリ
- 非同期レプリケーション・永続化
- 管轄外のデータへのリクエストはリダイレクトされる。
- シングルスレッド

---

### 特徴

- 1000台までのクラスタ構成を想定している。
- Binary/Hash/Set/Listなどのデータ型をサポート。
- プロキシを噛ませる必要がないため高速
- 非同期で複製するため、データが消失する恐れがあるが高速。
- データの一貫性はほぼ保つ。（障害時に稀に壊れる）
- string/binary/set/list/mapなどのデータ構造を格納可能。
- 各ノードのデータの分担量を細かくいじれる。
- CASをサポート。
- 読み書きともに0.5msくらい。

---

### 使用例

- データの復旧が可能なキャッシュサーバ。
- 多少データが壊れることを許容する大量データを、高速に処理したい場合。

---

## Memcached

---

### 一言で

超高速なサーバー間の共有メモリ。

http://gihyo.jp/dev/feature/01/memcached
http://www.slideshare.net/AmazonWebServices/dat207
http://qiita.com/taruhachi/items/a844bf373623991873ff

---

### 仕組み

![](traditional_memcached_client.jpg)

- クラスタ構成は擬似的なもので、ノード同士はコミュニケーションしない。
- クライアント側がどこにアクセスするか決める。（consistency hashing）
- マスタデータは基本的に一箇所のみで複製もされない（揮発データ前提）
- データが保有メモリ量を超えると古いものから消されていく


---

### 特徴

- 揮発性データを扱うこと前提。
- 障害時のデータの一貫性に難あり？
- 読み書きともに0.2msくらい

データが消えてもいいからとにかく高速な読み書きがしたい場合のキャッシュサーバ

---

### 疑問

- ノード追加時にクライアントがどうやってそれを知るのか？
- 各クライアントで、対象ノード決定のアルゴリズムは統一できるのか？

---

## Cassandra

http://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlClientRequestsWrite.html
http://www.slideshare.net/doanduyhai/cassandra-introduction-40711134

---

### 一言で

複雑なクエリに強いKVS

---

### 仕組み

- Dynamoベース
- 読み書きノードを設定することでCAPの程度を調整可能
- filter、rangeでのクエリに対応可能

---

### 特徴

- SQLに近いクエリ（CQL）を扱える。
- CASサポート
- データセンター間での連携も可能
- Appleなど、超大規模（１０万ノード、PB級）での実績あり[Link](http://itpro.nikkeibp.co.jp/atcl/column/15/061500148/100500026/?rt=nocnt)
- データ構造の違う複数テーブルを扱える。
- 一貫性とパフォーマンスの度合いを調整できる。
- 読み書き共に10msくらい。

---

### 疑問

- 高機能なのであまり調べられてない。

---

## riak

http://www.slideshare.net/takahikosato/riak-24796781
http://www.slideshare.net/scixer/riak-28885715?related=1
http://www.slideshare.net/takahikosato/riak-24796781#30
https://speakerdeck.com/ksauzz/fen-san-detabesu-riak-to-obuziekutosutorezi-riakcs#9

---

### 一言で

運用が楽なKVS

---

### 仕組み
- Dynamo論文ベース
- 単純なKeyValueを扱う
- 障害時に他ノードへのデータの一時的な退避、復旧時に元に戻すなどを自動で行う。

---

### 特徴

- 障害時の処理が充実している。（中の人曰く、「障害が起きたら翌朝対応すればいい。」）
- MapReduce系、全文検索系の仕組みが充実してるらしい。

---

## couchbase

http://www.slideshare.net/CouchbaseJapan/couchbase-introduction20150611
http://www.couchbase.com/nosql-resources/presentations/couchbase-server-101.html

---

### 一言で

速くて万能なドキュメント指向データベース

---

### 仕組み

- マスタ・スレーブ式
- あるデータは特定のマスタが管理している。
- クライアント側が、データを格納しているノードを選んでにアクセスする。

---

### 特徴

- 周辺ツールが充実しているっぽい。
- 柔軟なクエリを投げられる。
- データセンター間レプリケーションなどできるらしい。
- memcached互換のプラグインがある。
- 読み書きともに1msくらい。

---

## Aerospike

http://blog.hirokikana.com/?p=590

---

### 一言で

Redisのさらに永続化強くしたやつ。

---

### 仕組み

- 詳しく調べてない。
- マスタースレーブ式
- あるデータは一つのマスタが管理している。
- クライアントが対象のマスタを選んでやりとりする。
- 同期レプリケーション・永続化を行いつつも高速。

---

### 特徴

- 詳しく調べてない
- 同期的に永続化してるのに速い。

---

## kyototycoon

### 一言で

オワコン？（メンテされてなく、古い資料しかない）

---

## 実務のお話

---

## 依頼

既存KVS（TokyoTyrant）が遅い＆古い、のでリプレイスしたい。

---

## requirement

旧サービスのセッションの管理に用います。(オンプレ限定)

- オンラインでノードの追加・削除ができる。
- 一台落ちても稼働し続けられる
- （オンメモリで）高速に処理できる
- パフォーマンスの観点からオンプレ前提で、最低２台から運用できる。（ハード調達）
- ある程度枯れている。ノウハウが転がっている。
- 一定時間置くたものはexpireできる。
- データ量は数十GBを想定
- トランザクションは不要だが、できる限り最新の値がほしい。
- ある程度のデータロスとは許容するので、最悪の事態に備えて永続化したい。
- get/set/multi set/multi getのみ必要。

