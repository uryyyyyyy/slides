
### 13 クラスとメンバーへのアクセス可能性を最小限にする

#### 理由
影響範囲を特定しやすいから

#### コメント
当たり前のことなので割愛。

「そんなことわかってるけどどうすればいいのさ！」って人は相談しに来てくれれば良いと思います。

ライブラリ系を作成することは多くないと思うので、
そこまで厳密でなくても多分だいじょうぶ。

ただ、import文でワイルドカード「*」を使うと影響範囲が膨大になるので避けるべき。

---

### 14 publicのクラスではgetter/setterを使う

#### 理由

- 少しだけ柔軟性があがる。（ほぼ意味ない）
- スレッドセーフになりやすい？
- 参照先を追いやすくなる？

#### コメント
getterとsetter提供してたらpublicと同じ。

immutableにすればそんな心配しなくていい。

というか、**可変にしておきたい明確な理由がない限りはfinalをつけるべき**


---

### 15 可変性を最小限にする

#### 理由
- setter()を作らない。
- 変数をfinalにする。

設計・実装・利用・（デバッグ）が容易になるから。

不変だったらスコープ長くても変な値入らないよね。

--

#### コメント

さっきの理由に加えて、不変オブジェクトはスレッドセーフになるので使いやすい。

不変すげーって感じですが、欠点として、

- 使いこなすのが難しい（パラダイムシフトが必要です）

- 値が書き換わった時には別のインスタンスを作るコストがかかる

不変が損な例）

```java
String sample
sample = sample + “moke1”;
sample = sample + “moke2”;
sample = sample + “moke3”;
```


※継承されうるならそれは可変になってしまう（定義をオーバーライドされる）ので注意が必要。（後述）

---

### 16 （実装）継承よりコンポジションを選ぶ。

#### 理由
具象クラスを継承するとカプセル化が壊れる。（後述）

サブクラスが上位クラスにがっつり依存してしまう。（まぁ当然ですが）

そうでなくて、サブクラスっぽいものが上位クラスっぽいものを所有する（フィールド変数に入れる）形にすれば副作用はない。

#### コメント
サンプルで書かれていた具体例が継承していてよくわからなかったのですが、
フィールド変数として持っておけば、継承とほぼ同等のことができるから継承使うなという話です。


--

#### コラム

なぜ継承したらカプセル化が壊れるのか？

※あとで書く


---


### 17 キチンと設計や文書化しないなら継承を使うな

#### 理由
誰が見ても自明であるもの以外は継承を使うと混乱するから。
そして、誰が見ても自明なんて存在しないから。


#### コメント
安易に継承を使うと、自分の中だけでしかわからないものになります。

例えば、人クラスが動物クラスを継承していたとして、
動物クラスが持ってるメソッドやフィールドを全ての人で一致できますか？

- eat()はある？
- double weight (kg) は単位が違うかも？
- cry()は人だけ持ってる？動物も持ってる？

---

### 18 抽象クラスよりinterfaceを選ぶ。

#### 理由
抽象クラスはExtendsしなくてはならず、複数の継承（ミックスイン）ができないため。


#### コメント
自動車クラスが、乗り物クラスも機械クラスも実装したいというのはよくある話しかと。

```java
class CampingCar implements Home, Car{
	stay()
	drive()
}
```
みたいなｗ

---

### 19 型を定義するためだけにInterfaceを使う。

#### 理由
interfaceは定数など具体的なものを宣言するものではない。
あくまで概念的な振る舞いを記述するもの（多態性）

定数を使いたければUtilityクラスに書くべし。

#### コメント
そもそもinterfaceに定数って宣言できるんですね。知らなかった。

---

### 20 タグ付き（状態を持つ）クラスよりクラス階層を選ぶ。

#### 理由

```java
if(state == "fine"){
 //some logic
}else if(state == "bad"){
  //some logic
}

```

みたいなのがいっぱいあるような場合です。

状態をいくつか持っていて、毎回if分岐で処理させるのは無駄や抜け漏れが多いので、
クラスを分けて書くべき。（上記の例なら、FineStateクラス, BadStateクラスみたいな）
そのほうがメソッドがすっきりするし、状態を持たなくて済む。


#### コメント
デザパタのStateパターンですね。
このくらいなら継承を使っても許されるかもしれません

---

### 21 関数オブジェクトを使用する。

#### 理由
例）
```java
public class StudentNoComp implements Comparator {
        public int compare(Object o1, Object o2) {
                return ((Student)o1).getNo() - ((Student)o2).getNo();
        }
}
```

```java
Student[] ume = new Student[5];
                ume[0] = new Student(2, "木下　保美", 141.5);
                ume[1] = new Student(5, "湯水　敦", 145.0);
                ume[2] = new Student(1, "相田　徹", 152.5);
                ume[3] = new Student(4, "目加田　重三", 136.0);
                ume[4] = new Student(3, "橋　航", 145.0);

                Arrays.sort(ume, new StudentNoComp());
                for (int i = 0; i < ume.length; i++) {
                        ume[i].printStudent();
                }

```


関数型言語っぽい実装ができて便利だから。
また、APIの中にはそれを要求しているものも多いので。

--

#### コメント
Strategyパターンですね。
interfaceで定義したメソッドの中身を都度定義してあげることで関数っぽく扱えます。

メソッドを引数に渡すなんてできないでしょ？と思ってますか？

引数で渡すインスタンスのフィールドに1つのメソッドしかなかったら、
それは関数を引数にしてるのとほぼ同義でしょう。

よく見るのがsort用のComparatorでしょうか。
3章でやりましたね？

---

### 22 staticのメンバークラスを選ぶ。

#### 理由
外側のクラスのインスタンスの中にある時点で
インナークラスもインスタンスみたいなものなので、
わざわざインナークラスのインスタンスを毎度作るのは
処理やメモリの無駄遣い。

#### コメント
正直ピンと来ません。使いドコロ浮かばないし。。

インナークラスをstaticにした場合、外側のインスタンス生成時に勝手に作られるんですよね？きっと。


---

[続く→](chapter5.html)