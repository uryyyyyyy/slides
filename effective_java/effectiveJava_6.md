
### 30 int定数の代わりにenumを使用する

#### 理由

```java
public static final int APPLE_FUJI = 0; 
public static final int APPLE_PIPPIN = 1; 
public static final int APPLE_GRANNY_SMITH = 2; 
public static final int ORANGE_NAVEL = 0; 
public static final int ORANGE_TEMPLE = 1; 
public static final int ORANGE_BLOOD = 2; 

```


```java
public enum Apple{
	FUJI("1"),
	PIPPIN,
	SMITH;
}
public void sample(Strng input){}

if(input.equals(Apple.FUJI.toString)){
 //some logic	
}
}

```

よくある悪い例。int i = APPLE_FUJI　+ ORANGE_TEMPLE;
とかってミックスジュースが出来てしってもコンパイラさんは文句を言いません。

--

ここで、じゃあ定数をやめて文字列にしよう、というのもありですが、その際は文字列比較のコストが大きくなります。

また、数字、文字列のいずれにしても、想定外の値を誰かが入れてしまうことは避けられません。

曜日もいいね。


#### コメント

enumは使いづらく思われがちですが、ただのstaticな定数に過ぎないです。

---

### 31 序数の代わ り にイ ンスタンスフィール ドを使用する

#### 理由

ordinalという標準のメソッドがあるが、これに依存するとenumの意味がなくなる。
例えば、enumの三番目の値が欲しいとか書くと変更に弱い。

#### コメント
追求しない。
使ってはいけないメソッドは知らないに限る。

---

### 32 ビットフィールドの代わりに EnumSetを使用する

#### 理由
enumsetは、enumの要素のセットです。
そのままですね。

tatoebakonnna

```java
example

```

#### コメント
普通のセットと同じですが、いくつか便利なメソッドがあるのと、たぶん最適化とかされてるので普通はこっちを使えばいいでしょう。セットインターフェースを実装してるので以降は容易です。

---

### 33 序数インデツクスの代わりにEnumMapを使用する

#### 理由
```java
example

```

先ほどと同様に序数は不安定だから。また、インデックスに配列を使うと形安全性がなくなる。

#### コメント

要素から値を取り出すやり方は記述したので参考にしてください。

---

### 34 拡張可能な enumをインタ フ ェ ースで模倣する

#### 理由
```java
example

```

enumはインターフェースも実装できます。


#### コメント
下手に使うと混乱するのでオススメしないが、OOP的には自分の役割が明確にあるといいかも。

---

### 35 命名パターンよりアノテー ションをえらぶ。

#### 理由
```java
example

```

命名パターンで、これはテストメソッドと定義したとしても、それはコンパイラにはわからなく、変な命名でも問題なく通るが、そのメソッドはテストされない。

アノテーションで明示するとコンパイラが、あぁコイツはコントローラか、とわかる。

#### コメント

スプリングでも多用される手法。
例えば、「このデータはここにDIしてね。」とか、
「このクラスはコントローラね」
とか。
特にメソッドに有効。クラスには後述するマーカインタフェースが有用。

---

### 36 常にOverrideアノテーションを使用する。

#### 理由
```java
example

```

もしオーバーライドできてなかったときにエラーを履いてくれる(引数が違うとか名前間違えたとか。)

#### コメント

---

### 37 型を定義するためにマーカーインタフェースを使用する

#### 理由
```java
example

```
実際に動かす際も規定できる,


#### コメント
先ほどのアノテーションと同様に、コンパイラにわからせるために使う。

---

[続く→](chapter7.html)
