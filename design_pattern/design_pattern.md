
バイソフトウェアデザイン

## 基本

## そもそも良いコードとは？

- 初めてでも理解しやすい設計。
- 拡張しやすい設計
- 変更に強い設計

そのためには
- 役割を分割する。
- 作法、コーディング規約を準拠する。
- デザインパターンに則る。

--

## そのための手法がオブジェクト指向。

- 変更するコードは少なくて済む
- 役割が適切に分割される。

### よくない例。
- 神クラスの存在。
あれもこれもできる、は最悪の設計である。
これしかできない、を量産すべき

- 俺メソッドで作る。
まずは作法を知らないと、
効率も落ちるし車輪の再発名をしがち。

--

たとえばこんな設計
動作もデータも色々あります。
例えば
ユーザーの取得
コンソールに出力
時間によって挙動を変える

時間オブジェクト
ユーザーオブジェクト
挨拶の文面

などなど。
これらを部品化して個別に付け替えできるようにするのがオブジェクト指向です。

状態が変わりうるオブジェクトを持たない。そのオブジェクトも可変な状態を持ってしまう。

コンストラクタで呼ぶクラスはメソッドクラス。
メソッドで使い捨てるのはデータオブジェクト。
サービスクラスやDAOクラスは状態なんて持たなくていい。DTOだけでいい、、、
のだが、複数スレッドで並列処理させるためにはオブジェクト持たせる方が良かったりする。

イフ分の代わりに列挙型を使う。

状態が変わりうるオブジェクトを持たない。そのオブジェクトも可変な状態を持ってしまう。

コンストラクタで呼ぶクラスはメソッドクラス。
メソッドで使い捨てるのはデータオブジェクト。
サービスクラスやDAOクラスは状態なんて持たなくていい。DTOだけでいい、、、
のだが、複数スレッドで並列処理させるためにはオブジェクト持たせる方が良かったりする。

--













## デザインパターン

なぜデザインパターンを学ぶのか。

### デザインパターンの原則
- OCP（Open Closed Principle）
拡張はしやすく、しかし既存クラスへの修正は行わない。
→そのためにはなるべく他のクラスを知らなくて良いように作る必要がある。

### デザインパターンの利点。
- それぞれの役割が明確に分担されているのでわかりやすい。
- もはや共通言語としてエンジニアと会話ができる。
- 既存の設計を理解しやすくなる
- 設計における基本パターンを知ることで、設計にかける時間が減る。
- 変更箇所・影響範囲が少なくて済む。


---

## もしこういった設計を行わないと?

なんでもできる神クラス（一万行）をみんなで使うことになるでしょう。

もしこの神クラスにバグがあって、
フィールド変数の型をintからfloatに変えなきゃいけないとします。

すると影響範囲は神クラス内の全てのコードです。
一万行のコード、全てチェックできますか？
絶対にバグ- デグレがないと言い切れますか？

神クラスでは生き残れない。（チョイ閲覧注意）
<iframe width="420" height="315" src="//www.youtube.com/embed/WLKk00OYKhU" frameborder="0" allowfullscreen></iframe>

---

ちなみに知っといて欲しいのは、

**コードの行数を減らすこと＝良いこと、ではない。**

重要なのは、わかりやすく、ミスしにくい記述をすること

※（Javaで）デザインパターンをきちんと実装するとだいたい記述量が増える。

しかし、それぞれのクラスで役割が明確に定義される（interface、例外処理、final修飾子、メソッド分割など）と堅牢性- 拡張性は上がるので良いコードになり、結果的に楽になる。

記述を共通化するのは、役割をきっちり分担する&&今後絶対に全く同じ動作をすべき（違っていたら困る）場合にはまとめたほうが間違いがないからまとめているだけ。
その結果コードが短くシンプルになるだけで、ムリヤリ行数を減らす（本来違うものをまとめる- 特殊な記述をする。）のはNG

---

と、言いつつ,

## デザインパターンは使うな

- 現実世界を忠実にプログラミングする、というオブジェクト指向の思想のもと、継承をガンガン使います。
- その結果、他の人が見て修正しづらい、追いにくくなるようです。
- また、覚えたての素人がデザインパターンを使おうとすると、使うべきでない所に使ってしまいます
- そういう意味で、デザインパターンは基本使わないでください。これらを学ぶ意義は、その思想・利点を理解することです。（ワークス流の4-layerモデルも後ほど説明します。）
- （意識してなかったけど後から見返したら○○パターンっぽい、くらいでちょうどいいかもしれません。）

---

## もしかして→「難しい」？
とりあえずイメージだけ掴めばオッケーです。
実務ベースのものはオフラインで聞いて下さい。

---

さて、本編。
全部で23つ。ものすごく簡単に行きます。
詳しくはググってください
イマドキ使わないものもあるらしいので、そこらへんはATE的な人（∋柴田）に聞いてください。

http://www.techscore.com/tech/DesignPattern/index.html/


---

## Iterator Pattern
何かしらの複数形、books、〜listなどに対して順番に中身を辿っていく。
→Java5からは拡張for文が使えるので基本使わないかと。
（逆順に辿りたいとかならIteratorも有用?）

---

## Adapter Pattern
別名ラッパーパターン
委譲によって、お互いが相手の実装を知らなくても問題なくなる。
既存のクラスを変更したくない時に間に一枚かませる。
→例ではextend使っていたが、interface噛ませれば十分なはず。

---

## Template Method Pattern
Abstractクラスで一部のメソッドの中身まで定義してしまって、
継承先はわざわざその処理を書かなくてよくなるパターン。
→継承をガッツリ使うのでオススメしない。（後述するストラテジーパターンなどで代替）

継承先の全てのクラスにおいて全く同じ動作をしなければいけない&&大量のクラスがそれを実装する必要がある、
ならTemplateを使ってもいいとは思います。
（繰り返しますが、使いこなせる自信が無いうちはは使わないで下さい）

---

##Factory Method Pattern
インスタンスの作り方を継承元で決めたTemplateパターン。
→インスタンスの作り方を定義した別メソッドに移譲すればいい気がします。

---

##Singleton Pattern
プログラム中でそのクラスのインスタンスが一つしか存在しないことを明確にする。
→おそらく製品でもよく使われているので覚えておくと良い（getInstance()とかあったら多分コレ）
※複数スレッドから呼び出される可能性に注意。そこらへんはややこしいのでここでは省略。
Staticフィールドとの違いがよくわかっていません。作成されるタイミングの違いくらいでしょうか？

---

##Prototype Pattern
new コンストラクタでなく、既存のインスタンスをコピーしたい場合
java.lang.Cloneableインターフェースを実装してclone(Hoge obj)を実装する。

※コピーには2種類ある
DefaultではshallowCopy（作ったインスタンスがclone元と同じインスタンスを共有する。A==B）
もし全く独立した同じ値のインスタンスが欲しい場合はDeepCopy（A.equals(B) && A!=B）するcloneメソッドをOverrideして自分で作る。

---

##Builder Pattern
複雑なオブジェクトをnew〜〜だけで作るのではなく、段階を踏んで作り上げるパターン。
オブジェクトのフィールド変数は基本はfinalを付けたいけど、一度にnewするのが難しい場合に
中間値として保存しておくのに使う。（EffectiveJavaの２番めに出てくるのがいい例）

---

##Abstract Factory
Factory Patternと違い、インスタンスの生成の仕方もabstractにしたパターン。
→使いドコロはわからない。

---

##Bridge Pattern
機能の追加と実装の追加の橋渡しを行う。
→これを使うとクラスの階層が深くなるから嫌だし、
実装の追加するなら別のimplクラス作る or 機能の追加なら別のクラスに処理を移譲するべき。
と思うので必要ないと思う。

---

##Strategy Pattern
interfaceを実装するだけ。別の処理をさせたいときに実装クラスを差し替えるだけで済むので、
変更箇所を最小化できる。
→すごく使いやすく汎用的なパターンです。ATE採用面接はこのパターン知らないと落ちるそうです。

---

##Composite Pattern
再帰的な処理をしたい場合に用いる。
（例：あるフォルダ以下のファイルorフォルダの中身を検索したい時とか。
　対象がファイルならその内容を探り、対象がフォルダなら中身のファイルを探る、の繰り返し。）
→「再帰」処理と聞いて理解できる人は多くないと思うので割愛。
関数型言語などでは必須な考え方かも。

---

##Decorator Pattern
あるオブジェクトに後からどんどん装飾を施していくパターン。
（例：シンプルなケーキにイチゴやキャンドルなどをデコレーションしていく、みたいな）
→わざわざクラスを作らなくても関数で代替できる気がするので、使いドコロがわからない。。。

---

##Visitor Pattern
データ構造と処理を分離させる。
受け入れ役（Acceptance- データ構造）は訪問者（Visitor- 処理）を知る必要がない実装にする。
Visiterがその都度最適な処理を実行する。
→データ構造は、自分自身が何に使われるのかを知る必要はないし、知るべきではない。
後述する4-layerモデルはこのパターン使ってると思います。

---

##Chain of Responsibility Pattern
そのクラスで対応ができない処理は別のクラスに処理を投げる。たらい回しにするイメージ。
→このパターン下手に使うとヤバそう。。。
「これはどこで処理する」ってのは実装段階で知っとくのが普通だと思うので、次のFacade Patternの方が実用的なのでは？

---

##Facade Pattern
ある処理をする時はここに聞けばいい、といった共通の窓口を置くパターンです。
→WEBAPIとかもそうですかね。仕組みは知らないけどそこ叩けば演算してくれる。
移譲に近いものかと。(窓口が処理するというより、窓口が適切なところに処理を投げるわけですが。)

---

##Mediator Pattern
お互いが密に相関する処理の場合、仲裁者を間に挟むことで、オブジェクトは仲裁者だけ知ればよくなる。
もし仲裁者がいなければ、各オブジェクトは相関する全てのオブジェクトを知らなくてはいけない、すると変更に弱くなる。
（例： 個々で売買しなくても、質屋を介せばみんな質屋だけ知っていればいい。）

→使い所はわかりません。

---

##Observer Pattern
観測者に対して各オブジェクトが変更や処理を報告するパターン。
Mediatorに似て、こちらも観測者が報告などを一手に引き受けます。インターフェースを噛ませることで、別の観測者に変わっても同じように処理することができます。
→変更すべきでない中枢は最小限のメソッドだけ持ち、変更されやすい末端部分がメッセージを投げるイメージでしょうか。

---

##Memento Pattern
処理の途中結果を一時的に保存しておくパターン。ゲームで言うセーブポイントみたいなものですかね。
再現するときに処理を省略できるのが利点。
→使い所はわかりません。

---

##State Pattern
状態によってクラスを変える。
（例 機嫌のいい柴田クラスと、悪い時の柴田クラス。）
これによって柴田に機嫌ステータスを持たせる必要がなくなり、
if分岐（if（良い柴田） elseif（悪い柴田）みたいな）の抜け漏れがなくなる。
機嫌パラメータが増える時は新しくクラスを作れば良い。
→モノによっては良い実装だと思います。
例えば、現在の年度によってif分岐させるのではなく、「２０１３年度用の給与計算ロジッククラス」とか。

---

##Flyweight Pattern
同じものは使い回す。
（例：画像表示など、何度も同じ画像をロードするより並べた方が早い。）
内部にキャッシュを持つイメージ。共有するので中身を書き換える際は注意。

---

##Proxy Pattern
自分が処理できない場合はできるやつに処理を任せる。処理の分割。
→移譲とほぼ同義と思います。

---

##Command Pattern
ものでなく命令をオブジェクトとして扱う。
処理をするクラスにパラメータなどをハードコーディングするのではなく
引数に持たせることで条件が変わっても処理自体を変えなくて済む。
→４−Layerモデル（後述）でも取り入れていると思う。
ロジック部が状態（マジックナンバー等）を持たないクラスになるのでわかりやすくなる。

---

##Interpreter Pattern
構文解析として処理していく。一つの処理で一つのクラス。役割の分割。
→難しいし使わないと思うので割愛。

---

以上、ざっくりの説明でした。詳しくはWebで。

（処理の丸投げ→Proxy Pattern）



---

## ここから本題です！

ここから本題です。頑張ってください。

画像

まずは4layerから。間にインターフェース挟むのも可

---

図にするとこんなカンジ。
（4layer）

---

単語の説明
データオブジェクト
※柴田が勝手に名づけたもの。
フィールド変数だけ持ち、メソッドは持たない（getter/setter・equals・hashcodeなどは例外）
DTO、VO、Entityクラスが該当する
全ての変数にfinalつけるのが理想


ロジックオブジェクト
※柴田が勝手に名づけたもの。
メソッドだけ持ち、フィールド変数を持たないもの（＝状態を持たない）
Service、Controller、DAO、Logicクラスが該当する

自然とStatelessな設計になる。
※equals()などがなぜ必要かはCollection系の実装のため
---

単語の説明
Controller
Service（Interface）とViewしか知らない
ユーザーのアクションが来たらServiceに処理を投げてViewに返す。
入力値のバリデーションを行うこともある

Service
DAOとLogicしか知らない
Controllerから来たものをDAOやLogicを駆使して適切に処理して返す。
Controllerから来たデータは、始めにチェックを行い不正データやnullはエラーを返す。


---

単語の説明
DAO
Entityしか知らない。
SQLやDB接続の設定などは別ファイルに記述することもある。
DBから返ってきたものは「確実に」nullチェックなど行い正常なデータだけ返す。
EntityからVOへのConvertメソッドを持ってるのが普通かな

Logic
純粋な演算クラス。極力他のクラスを知らないべき
複数のServiceで行いたいような処理を役割毎に請け負っている。

---

単語の説明
DTO
使い方はまちまちだが、主にViewなどへ送られる用のデータ（Transferだから）

Entity
DBのカラムと全く同じフィールドを持ったオブジェクト
実装はORマッパーによって異なるので一概にいえないかも
複数テーブルから一度に取ってくる場合、Entityを介さないこともある。

---

単語の説明
VO（Value Object）
APサーバー内で処理するデータを役割毎にまとめた（primitive型をラップした）もの
※なるべく処理中はprimitive型（intやChar）を使うべきでない。汎用的すぎてどう使うかわからない・間違った使い方をされる恐れがあるから（例えば、method（int hoge, int moke）と言われて、引数にどの値を入れていいのかわからないよね。）

View
HTMLやDelphiなど、UI側
特に説明は不要でしょう。

---

この設計の利点
それぞれの役割が明確に分かれている
メソッドに副作用が（ほぼ）ない。状態を持たないから
デバッグがしやすいし、影響範囲も絞れる。

---

継承を使うべきでない理由

これ、覚えきれます？

gazou gazou


---

継承を使うべきでない理由
継承の目的はなにか？
メソッド・フィールドを継承先が必ず持っていることを明確にすること。
継承元にそれらが書かれているので記述量が減る。
デバッグがしやすいし、影響範囲も絞れる。
しかしデメリットとして
メソッドなどが継承先に書かれないのでわかりにくい。（継承元まで全部たどる必要がある）
直感的にイメージしづらいものが多い
（IVcDDがSrwDateを継承してる、って言われて、「あぁ、あの変数とあのメソッド使ってんのね」とかわからないよね）
全員が間違いなく理解できるもの以外使っちゃダメ、逆に混乱するから。

---

継承を使うべきでない理由
継承には代案があります。（Aを継承元, Bを継承先とします。）
データオブジェクトの場合
フィールド変数を利用したいだけなので、BクラスはAクラスのインスタンスをフィールドに持ってしてしまえばいい
例：
ロジックオブジェクトの場合
名称を同じにしてポリもルフィズムを使いたい→interfaceを切ればいいだけ。
ロジックの中身をそのまま使いたい→Bに実装しないで、BからAへ移譲する書き方をすればいい。中身をそのまま実装したいというのは単一責務に反する。
例：

---

継承を使うべきでない理由
以上、継承は使わない議論終わり。（これ話すには単語など下地が必要だったのでこのタイミングで）
継承をどうしても使いたい場合は、周りのエンジニア全員に 誰が見ても理解できるか了承を取ってから作って下さい。







## これがどういいのか？
### 状態を持たないので変な副作用がない。
→この設計を行えばロジック部分が状態を持つことは無いですね。
以前から言ってますが、保守性を高めるには状態を持たない関数のほうが、イミュータブル（不変）な方が良いのです。
関数とは？例の写真 

### 役割分担されているので影響箇所が特定しやすい。
例えば、
ControllerはServiceとViewしか知らない。
ServiceはDAOとLogicしか知らない
DAOはServiceしか知らない。
LogicはServiceしか知らない。
### デバッグもしやすい。

---
